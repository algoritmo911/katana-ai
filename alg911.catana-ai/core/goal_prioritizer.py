import datetime

class GoalPrioritizer:
    """
    Analyzes a state report and self-generated meta-goals to create a single
    prioritized list of goals for the agent to pursue.
    """
    def __init__(self, priority_config=None):
        """
        Initializes the GoalPrioritizer with a priority configuration.
        """
        # Goals generated by the Telos meta-cognitive loop
        self.meta_goals = []

        if priority_config:
            self.priorities = priority_config
        else:
            # Default priority mapping for environment-reactive goals
            self.priorities = {
                'critical_error': 1.0,
                'unanswered_question': 0.9,
                'performance_issue': 0.7,
                'db_query_failed': 0.8, # Internal health check
                'log_read_failed': 0.8  # Internal health check
            }

    def add_meta_goal(self, goal: dict):
        """
        Adds a high-level goal from the Telos loop to the queue.
        """
        if goal and isinstance(goal, dict) and "goal" in goal:
            print(f"GoalPrioritizer: Received meta-goal -> {goal.get('goal')}")
            self.meta_goals.append(goal)

    def prioritize_goals(self, state_report):
        """
        Takes a state report and returns a sorted list of goals.

        :param state_report: The dictionary generated by StateMonitor.
        :return: A list of goal dictionaries, sorted by priority in descending order.
        """
        goals = []

        # 1. Check for critical errors in logs
        if state_report.get('critical_errors'):
            for error in state_report['critical_errors']:
                # Handle cases where the monitor itself failed (returns a dict)
                if isinstance(error, dict) and 'log_read_failed' in error.get('error', ''):
                    goals.append({
                        'goal': 'notify_admin_about_log_failure',
                        'priority': self.priorities['log_read_failed'],
                        'details': error,
                        'source': 'StateMonitor'
                    })
                # Handle regular log errors (which are strings)
                else:
                    goals.append({
                        'goal': 'notify_admin_about_crash',
                        'priority': self.priorities['critical_error'],
                        'details': {'error_log': str(error)},
                        'source': 'StateMonitor'
                    })

        # 2. Check for unresolved tasks from DB
        if state_report.get('unresolved_tasks'):
            for task in state_report['unresolved_tasks']:
                if 'db_query_failed' in task.get('error', ''):
                    goals.append({
                        'goal': 'notify_admin_about_db_failure',
                        'priority': self.priorities['db_query_failed'],
                        'details': task,
                        'source': 'StateMonitor'
                    })
                else:
                    # Assuming the task object from DB contains user_id and other context
                    goals.append({
                        'goal': 'answer_user_question',
                        'priority': self.priorities['unanswered_question'],
                        'details': task, # Pass the whole task object for context
                        'user_id': task.get('user_id'),
                        'source': 'Supabase'
                    })

        # 3. Check for performance issues
        if state_report.get('performance_issues'):
            for issue in state_report['performance_issues']:
                goals.append({
                    'goal': 'investigate_performance_issue',
                    'priority': self.priorities['performance_issue'],
                    'details': issue,
                    'source': 'Telemetry'
                })

        # Add self-generated meta-goals to the list
        if self.meta_goals:
            goals.extend(self.meta_goals)
            # Clear the list after adding them to prevent re-processing
            self.meta_goals = []

        # Sort all goals by priority, highest first
        # Note: Meta-goals must have a 'priority' key to be sorted correctly.
        sorted_goals = sorted(goals, key=lambda g: g.get('priority', 0.0), reverse=True)
        return sorted_goals

if __name__ == '__main__':
    # Example usage for testing
    prioritizer = GoalPrioritizer()

    # Mock state report
    mock_report = {
        'unresolved_tasks': [
            {'id': 1, 'user_id': 'user123', 'last_message': 'Hello, are you there?', 'last_message_timestamp': '2023-10-26T10:00:00Z'}
        ],
        'critical_errors': [
            '[2023-10-27T12:00:00Z] CRITICAL: Main process crashed with signal 9.'
        ],
        'performance_issues': [
            {'issue': 'high_response_time', 'avg_response_ms': 2500}
        ],
        'report_timestamp': datetime.datetime.now(datetime.timezone.utc).isoformat()
    }

    print("--- Testing with a full report ---")
    prioritized_goals = prioritizer.prioritize_goals(mock_report)
    import json
    print(json.dumps(prioritized_goals, indent=2))
    # Expected output: Critical error first, then user question, then performance issue.

    print("\n--- Testing with only a user question ---")
    mock_report_user_only = {
        'unresolved_tasks': [
            {'id': 2, 'user_id': 'user456', 'last_message': 'I need help with my bill.', 'last_message_timestamp': '2023-10-27T11:00:00Z'}
        ],
        'critical_errors': [],
        'performance_issues': [],
        'report_timestamp': datetime.datetime.now(datetime.timezone.utc).isoformat()
    }
    prioritized_goals_user_only = prioritizer.prioritize_goals(mock_report_user_only)
    print(json.dumps(prioritized_goals_user_only, indent=2))
    # Expected output: User question goal only.

    print("\n--- Testing with a DB query failure ---")
    mock_report_db_fail = {
        'unresolved_tasks': [{'error': 'db_query_failed', 'details': 'relation "dialogues" does not exist'}],
        'critical_errors': [],
        'performance_issues': [],
        'report_timestamp': datetime.datetime.now(datetime.timezone.utc).isoformat()
    }
    prioritized_goals_db_fail = prioritizer.prioritize_goals(mock_report_db_fail)
    print(json.dumps(prioritized_goals_db_fail, indent=2))
    # Expected output: DB failure notification goal.
