import sys
import os
import requests # For n8n integration
import json

# Adjust path to import from the parent directory
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from lib import memory, nlp, telegram, admin_notifications
from schemas import Plan, Command, CommandType
from core.neurovault import Neurovault # Import Neurovault

class TaskExecutor:
    """
    Executes a plan by sequentially running its commands. It manages the
    data flow between commands using an execution context.
    """
    def __init__(self):
        """
        Initializes the TaskExecutor and its command registry.
        The registry maps command names to their handler methods.
        """
        self.neurovault = Neurovault() # Instantiate neurovault

        self.command_registry = {
            # Local Python function mappings
            "memory.retrieve_full_context": self._retrieve_context,
            "nlp.generate_answer": self._generate_answer,
            "telegram.send_message": self._send_user_message,
            "admin_notifications.format_error_report": self._format_report,
            "admin_notifications.send_admin_notification": self._send_admin_alert,
            "neurovault.add_knowledge": self._add_knowledge_to_neurovault,

            # n8n webhook execution mapping
            "n8n.webhook": self._execute_n8n_webhook
        }
        self.execution_context = {}

    def execute_plan(self, plan: Plan):
        """
        Executes the given plan step by step.
        """
        print(f"\n--- EXECUTING PLAN: {plan.goal} (ID: {plan.plan_id}) ---")
        self.execution_context = {} # Reset context for each new plan

        for i, command in enumerate(plan.steps):
            print(f"Executing Step {i+1}/{len(plan.steps)}: {command.name} ({command.type})")

            # Find the handler method in the registry
            handler_method = self.command_registry.get(command.name)

            if not handler_method:
                print(f"ERROR: No handler method found for command: {command.name}")
                # Terminate plan execution on failure
                return False

            try:
                # Execute the handler, passing the command's parameters
                handler_method(command.params)
            except Exception as e:
                print(f"ERROR: Task '{command.name}' failed: {e}")
                # Terminate plan execution on failure
                return False

        print(f"--- PLAN COMPLETE: {plan.goal} ---\n")
        return True

    # --- Command Handler Methods ---
    # These methods wrap the actual business logic. They use
    # self.execution_context to manage state between steps.

    def _retrieve_context(self, params: dict):
        user_id = params.get('user_id')
        details = params.get('details')
        if not user_id:
            raise ValueError("user_id not found in command params")

        context = memory.retrieve_full_context(user_id, details)
        self.execution_context['full_context'] = context
        print("  - Context retrieved for user_id:", user_id)

    def _generate_answer(self, params: dict):
        context = self.execution_context.get('full_context')
        if not context:
            raise ValueError("full_context not found in execution context")

        answer = nlp.generate_answer(context)
        self.execution_context['generated_answer'] = answer
        print("  - Answer generated by NLP model.")

    def _send_user_message(self, params: dict):
        answer = self.execution_context.get('generated_answer')
        user_id = params.get('user_id')
        if not answer or not user_id:
            raise ValueError("Answer or user_id missing for sending message")

        telegram.send_message(user_id, answer)
        print("  - Message sent to user_id:", user_id)

    def _format_report(self, params: dict):
        details = params.get('details')
        if not details:
            raise ValueError("Goal details not found in command params")

        report = admin_notifications.format_error_report(details)
        self.execution_context['admin_report'] = report
        print("  - Admin report formatted.")

    def _send_admin_alert(self, params: dict):
        report = self.execution_context.get('admin_report')
        if not report:
            raise ValueError("Admin report not found in execution context")

        admin_notifications.send_admin_notification(report)
        print("  - Admin notification sent.")

    def _add_knowledge_to_neurovault(self, params: dict):
        """
        Adds knowledge, presumably from the result of a previous step,
        to the Neurovault.
        """
        n8n_response = self.execution_context.get('n8n_response')
        if not n8n_response:
            raise ValueError("n8n_response not found in execution context for adding knowledge.")

        concepts = n8n_response.get("concepts")
        if concepts is None:
            raise ValueError("'concepts' key not found in n8n_response.")

        self.neurovault.add_knowledge(concepts)
        print(f"  - Added {len(concepts)} concepts to Neurovault.")

    def _execute_n8n_webhook(self, params: dict):
        webhook_url = params.get("webhook_url")
        raw_payload = params.get("payload", {})
        if not webhook_url:
            raise ValueError("webhook_url is required for n8n command")

        # Resolve context variables in the payload
        resolved_payload = {}
        for key, value in raw_payload.items():
            if isinstance(value, str) and value.startswith("context:"):
                context_key = value.split(":", 1)[1]
                resolved_value = self.execution_context.get(context_key)
                if resolved_value is None:
                    print(f"  - WARNING: Context key '{context_key}' not found in execution context.")
                resolved_payload[key] = resolved_value
            else:
                resolved_payload[key] = value

        print(f"  - Triggering n8n webhook: {webhook_url} with payload: {json.dumps(resolved_payload)}")
        try:
            # Using a mock URL for testing. In a real scenario, this would be a live webhook.
            if "n8n.katana.foo" in webhook_url:
                print("  - (Mock Execution) Pretending to call webhook.")
                self.execution_context['n8n_response'] = {"status": "success", "mock": True}
                return

            response = requests.post(webhook_url, json=resolved_payload, timeout=30)
            response.raise_for_status()
            print(f"  - n8n webhook returned status: {response.status_code}")
            self.execution_context['n8n_response'] = response.json()
        except requests.RequestException as e:
            print(f"  - FAILED to trigger n8n webhook {webhook_url}: {e}")
            raise e

if __name__ == '__main__':
    # Example usage for testing the new plan-driven executor
    from planner import Planner

    executor = TaskExecutor()
    planner = Planner()

    # --- Test Case 1: Answer a user question ---
    print(">>> TEST CASE 1: Answer User Question <<<")
    user_question_goal = {
        'goal': 'answer_user_question',
        'details': {'id': 2, 'user_id': 'user456', 'last_message': 'I need help with my bill.'}
    }
    plan_to_execute = planner.create_plan(user_question_goal)
    if plan_to_execute:
        executor.execute_plan(plan_to_execute)

    # --- Test Case 2: Notify admin about a crash ---
    print("\n>>> TEST CASE 2: Notify Admin of Crash <<<")
    crash_goal = {
        'goal': 'notify_admin_about_crash',
        'details': {'error_log': '[2023-10-27T12:00:00Z] CRITICAL: Main process crashed with signal 9.'}
    }
    plan_to_execute = planner.create_plan(crash_goal)
    if plan_to_execute:
        executor.execute_plan(plan_to_execute)
