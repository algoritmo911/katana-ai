import pprint
from typing import Any, Dict, List, Type

from pydantic import BaseModel


class TestScribe:
    """
    Generates a pytest test file for a given Pydantic contract and test data.
    """

    def __init__(self, contract_model: Type[BaseModel], test_cases: List[Dict[str, Any]]):
        self.contract_model = contract_model
        self.contract_name = contract_model.__name__
        self.module_path = contract_model.__module__

        self.valid_cases = [case['data'] for case in test_cases if case['is_valid']]
        self.invalid_cases = [case['data'] for case in test_cases if not case['is_valid']]

    def generate_test_file_content(self) -> str:
        """
        Generates the full content of a pytest file as a string.
        """
        # Pretty-print the data for inclusion in the parametrize decorator
        valid_cases_str = pprint.pformat(self.valid_cases)
        invalid_cases_str = pprint.pformat(self.invalid_cases)

        # Generate a conventional test class name from the contract name
        test_class_name = f"Test{self.contract_name.replace('Contract', '')}Command"

        # Generate a conventional API endpoint from the contract name
        endpoint_name = self.contract_name.replace('Contract', '').lower()
        api_endpoint = f"/commands/{endpoint_name}"

        # Using a template string to build the test file
        content = f'''"""
This test file was automatically generated by TestScribe.
It tests the {self.contract_name} contract.
"""

import pytest
from {self.module_path} import {self.contract_name}

# Note: This test assumes a 'client' fixture is available,
# which is common in web frameworks like FastAPI or Flask.
# The client should be an instance of a test client that can make HTTP requests.

@pytest.mark.parametrize("payload", {valid_cases_str})
def test_{endpoint_name}_with_valid_payloads(client, payload):
    """
    Tests that the endpoint for {self.contract_name} handles valid payloads correctly.
    """
    # We need to convert datetime and UUID objects to strings for JSON serialization
    for key, value in payload.items():
        if hasattr(value, 'isoformat'): # Datetime
            payload[key] = value.isoformat()
        elif hasattr(value, 'hex'): # UUID
            payload[key] = str(value)

    response = client.post("{api_endpoint}", json=payload)

    # Expecting a success status code (e.g., 200 OK or 201 Created)
    assert response.status_code in [200, 201], f"Expected status code 200 or 201, but got {{response.status_code}}. Payload: {{payload}}"

    # Optional: Further validation on the response body can be added here
    # For example, checking if the returned data matches the input
    # response_data = response.json()
    # assert response_data['username'] == payload['username']


@pytest.mark.parametrize("payload", {invalid_cases_str})
def test_{endpoint_name}_with_invalid_payloads(client, payload):
    """
    Tests that the endpoint for {self.contract_name} returns a validation error (422) for invalid payloads.
    """
    # We need to convert datetime and UUID objects to strings for JSON serialization
    for key, value in payload.items():
        if hasattr(value, 'isoformat'):
            payload[key] = value.isoformat()
        elif hasattr(value, 'hex'):
            payload[key] = str(value)

    response = client.post("{api_endpoint}", json=payload)

    # Expecting an "Unprocessable Entity" status code for validation errors
    assert response.status_code == 422, f"Expected status code 422, but got {{response.status_code}}. Payload: {{payload}}"
'''
        return content
