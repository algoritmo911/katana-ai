# -*- coding: utf-8 -*-
from __future__ import annotations
"""
The Quantum State Simulator (Python Prototype)

This module contains the simulator responsible for executing the quantum
circuits generated by the Gallifreyan compiler. It manages the state of
temporal qudits and applies the quantum-inspired operations.
"""
import copy
import random
from typing import Any, Dict, List, Tuple

from .ast import GateApplication, HandshakeDeclaration, Measurement, SimulationBlueprint, InterventionGate

# State is a list of (value, probability) tuples. Probabilities must sum to 1.0
ProbabilisticState = List[Tuple[Any, float]]
# Timestamp maps to a ProbabilisticState
QuditHistory = Dict[str, ProbabilisticState]
# Qudit name maps to its history
QuditRegistry = Dict[str, QuditHistory]


class QuantumStateSimulator:
    """
    Simulates the behavior of temporal qudits on classical hardware.
    """

    def __init__(self):
        # Stores the state of all qudits
        self.qudits: QuditRegistry = {}
        # Stores entanglement links between qudits
        self.entanglements: List[HandshakeDeclaration] = []

    def load_blueprint(self, blueprint: SimulationBlueprint):
        """Initializes the simulator's state from a SimulationBlueprint AST."""
        self.qudits = {}
        for qudit_decl in blueprint.qudits:
            self.qudits[qudit_decl.name] = {}
            for timestamp, state in qudit_decl.initial_states.items():
                # Ensure initial states are in probabilistic form
                if isinstance(state, list):
                    # Assume equal probability if not specified
                    prob = 1.0 / len(state)
                    self.qudits[qudit_decl.name][timestamp] = [(s, prob) for s in state]
                else:
                    # It's a single, collapsed state
                    self.qudits[qudit_decl.name][timestamp] = [(state, 1.0)]

        self.entanglements = blueprint.handshakes or []

    def execute_gate(self, gate_op: GateApplication):
        """Dispatches to the correct gate application method."""
        if gate_op.gate_name == "TARDIS_Gate":
            self._apply_tardis_gate(gate_op.target_qudit)
        else:
            raise ValueError(f"Unknown gate: {gate_op.gate_name}")

    def execute_intervention(self, intervention_op: "InterventionGate"):
        """
        Forces a qudit into a specific state and triggers the shockwave.
        This is a forced, deterministic measurement.
        """
        target_qudit = intervention_op.target_qudit
        forced_value = intervention_op.force_state_to

        history = self.qudits.get(target_qudit)
        if not history:
            raise ValueError(f"Cannot intervene on unknown qudit: {target_qudit}")

        latest_ts_str = max(history.keys())

        print(f"  [Intervention] Forcing {target_qudit} to '{forced_value}'")

        # Collapse the wave function to the forced value
        self.qudits[target_qudit][latest_ts_str] = [(forced_value, 1.0)]

        # --- Measurement Shockwave ---
        # The intervention acts as a measurement, so it triggers entanglements.
        self._resolve_entanglements(target_qudit, forced_value, set())

    def _apply_tardis_gate(self, target_qudit: str):
        """
        Applies a superposition to all future states of a qudit.
        This is a simplified example. A real gate would take parameters.
        For now, it finds the last known state and creates a simple
        binary superposition for the next timestep.
        """
        history = self.qudits.get(target_qudit, {})
        if not history:
            return

        # Find the latest timestamp to evolve from
        latest_ts_str = max(history.keys())
        # A simple way to name the next step
        next_ts_str = f"{latest_ts_str}_next"

        # This gate creates a simple forked timeline.
        # For example, a "checked" state becomes a superposition of "found_ok" and "found_anomaly".
        last_known_state_val = history[latest_ts_str][0][0] # Assuming it's collapsed

        new_superposition = [
            (f"{last_known_state_val}_outcome_A", 0.5),
            (f"{last_known_state_val}_outcome_B", 0.5)
        ]
        self.qudits[target_qudit][next_ts_str] = new_superposition


    def execute_measurement(self, measurement_op: Measurement) -> Any:
        """
        Collapses a qudit's state at the latest time into a single classical value.
        This is the "Angel's Gaze".
        """
        target_qudit = measurement_op.target_qudit
        history = self.qudits.get(target_qudit, {})
        if not history:
            raise ValueError(f"Cannot measure unknown qudit: {target_qudit}")

        # Find the latest timestamp to measure
        latest_ts_str = max(history.keys())
        superposition = history[latest_ts_str]

        # The core of measurement: weighted random choice
        states, probabilities = zip(*superposition)

        # The 'perspective' can bias the measurement
        # This is a placeholder for a more complex mechanic
        if measurement_op.perspective == "optimistic" and len(states) > 1:
            # Simple bias: double the probability of the first outcome
            # This is not physically realistic but models the concept
            probabilities = list(probabilities)
            probabilities[0] *= 2
            # Normalize to sum to 1 again
            total_prob = sum(probabilities)
            probabilities = [p / total_prob for p in probabilities]

        measured_value = random.choices(states, weights=probabilities, k=1)[0]

        # Collapse the wave function
        self.qudits[target_qudit][latest_ts_str] = [(measured_value, 1.0)]

        # --- Measurement Shockwave ---
        # Resolve any entanglements connected to the measured qudit.
        self._resolve_entanglements(target_qudit, measured_value, set())

        return measured_value

    def _resolve_entanglements(self, source_qudit: str, source_value: Any, resolved_in_this_shockwave: set):
        """
        Recursively resolve entanglements after a measurement.
        """
        if source_qudit in resolved_in_this_shockwave:
            return # Avoid infinite loops
        resolved_in_this_shockwave.add(source_qudit)

        for handshake in self.entanglements:
            other_qudit = None
            if handshake.qudit1 == source_qudit:
                other_qudit = handshake.qudit2
            elif handshake.qudit2 == source_qudit:
                other_qudit = handshake.qudit1

            if other_qudit:
                history = self.qudits.get(other_qudit, {})
                if not history: continue

                latest_ts_str = max(history.keys())

                # Simple entanglement rule: the other qudit collapses to a state
                # derived from the source qudit's measured value.
                entangled_value = f"entangled_from({source_qudit}={source_value})"

                print(f"  [Entanglement] {source_qudit}={source_value} caused {other_qudit} to collapse to {entangled_value}")

                self.qudits[other_qudit][latest_ts_str] = [(entangled_value, 1.0)]

                # For this phase, we stop the shockwave after one level to keep the demo clean.
                # A full implementation would require more sophisticated rules to prevent runaway cascades.
                # self._resolve_entanglements(other_qudit, entangled_value, resolved_in_this_shockwave)
