import aiohttp
import logging
from .interface_base import InterfaceBase # Assuming src is in PYTHONPATH or relative import works

logger = logging.getLogger(__name__)

class GemmaInterface(InterfaceBase):
    def __init__(self, api_key: str, api_endpoint: str = "https://api.kodjima.com/v1/query"):
        if not api_key:
            logger.error("GemmaInterface: API key is missing.")
            raise ValueError("API key is required for GemmaInterface.")
        self.api_key = api_key
from typing import Optional

# ... (other imports)

class GemmaInterface(InterfaceBase):
    def __init__(self, api_key: str, api_endpoint: str = "https://api.kodjima.com/v1/query"):
        if not api_key:
            logger.error("GemmaInterface: API key is missing.")
            raise ValueError("API key is required for GemmaInterface.")
        self.api_key = api_key
        self.endpoint = api_endpoint
        logger.info(f"GemmaInterface initialized with endpoint: {self.endpoint}")

    async def receive(self, payload: Optional[dict] = None) -> dict: # Matches InterfaceBase
        """
        Получить запрос от пользователя, вернуть контекст.
        For GemmaInterface, 'receive' means the system has received a 'payload'
        (e.g., from a webhook, CLI, or another part of the application)
        that needs to be processed and eventually sent to Gemma.
        This method simply returns the payload as is, assuming it contains the necessary
        information for the 'process_user_message' function.
        The actual call to the Gemma model happens in 'send' if this interface is
        about *sending responses from* Gemma, or it happens in 'process_user_message'
        if Gemma is the one *generating* the response.

        Given the task description "Подключить вызовы к Kodjima 3N E4B через её HTTP API",
        and "async def send(self, response: dict) -> None: ... async with session.post(self.endpoint, json=response, headers=headers)",
        it seems this interface is for *sending data TO* the Gemma/Kodjima API as the final step.

        So, `receive` here means receiving data from the client of *our bot*,
        and `send` means sending the *bot's response* (potentially generated by an LLM,
        which could be Gemma itself, but called elsewhere, e.g. in `process_user_message`)
        out through this Gemma-specific channel (e.g. if our bot was acting as a proxy
        or if Gemma had a way to push messages to users).

        Let's re-read: "Подключить вызовы к Kodjima 3N E4B через её HTTP API".
        This implies our application will *call* the Gemma API.
        If `GemmaInterface` is one of the *channels* like Telegram (e.g. a user interacts via a "Gemma" chat platform),
        then `receive` would get input from that platform, and `send` would send output to it.
        The current `send` method in the plan for `KodjimaInterface` (now `GemmaInterface`)
        `async def send(self, response: dict) -> None: async with aiohttp.ClientSession() as session: ... session.post(self.endpoint, json=response...`
        This looks like it's sending the `response` (generated by our bot's core logic after `process_user_message`)
        *to* the Gemma/Kodjima API endpoint. This is unusual if Gemma is the LLM *providing* responses.

        Let's assume the task means:
        1. User sends message via some channel (e.g. Telegram, or a direct HTTP call to our app).
        2. Our app's `main.py` uses an `InterfaceBase` implementation (e.g., `TelegramInterface`) for `receive()`.
        3. `process_user_message()` is called. *This function* might be the one that queries an LLM (like Gemma).
        4. The response from `process_user_message()` is then given to an `InterfaceBase` implementation for `send()`.

        If `INTERFACE=gemma` is chosen, it means the user is interacting with our application *as if* it's the Gemma API.
        - `GemmaInterface.receive(payload)`: This would mean our application receives a payload (e.g. via HTTP POST to our app).
        - `process_user_message(payload)`: Processes it.
        - `GemmaInterface.send(response_from_process)`: This would send the final response *back to the original caller* who made the HTTP POST.

        The `send` method in the plan for `KodjimaInterface` (which posts to `api.kodjima.com`) seems to be for sending data *to* Gemma, not *from* Gemma acting as an interface.

        Let's clarify the role of `GemmaInterface`:
        Option A: `GemmaInterface` is a channel like Telegram. Users send messages to it, get replies from it. The Gemma LLM itself is used within `process_user_message`. The `send` method in `GemmaInterface` would then use Gemma's API to *deliver a message to a user on the Gemma platform*. This is unlikely as Gemma is an LLM model, not a chat platform with users.

        Option B: `GemmaInterface` means our bot is exposing an API endpoint that *mimics* or is compatible with how one might query Gemma. `receive` gets this request. `send` sends the response back to the HTTP client. The `self.endpoint` and `self.api_key` in `GemmaInterface` would then be for *our application's own authentication* if it were proxying, or irrelevant if it's just a format spec.

        Option C: The `GemmaInterface` is actually a *client* to the Gemma LLM, to be used *inside* `process_user_message`, not as one of the pluggable I/O interfaces. This contradicts the overall goal "Отвязаться от специфики Telegram API и сделать слой интерфейса плагинным." and putting `GemmaInterface` alongside `TelegramInterface`.

        Let's stick to the plan's structure: `GemmaInterface` is an alternative to `TelegramInterface`.
        So, `receive` means getting data from "the Gemma user" (however they connect - likely an HTTP request to our app).
        And `send` means sending our bot's response back to "the Gemma user".

        The `send` method defined in the task:
        `async def send(self, response: dict) -> None: async with aiohttp.ClientSession() as session: headers = {"Authorization": f"Bearer {self.api_key}"}; async with session.post(self.endpoint, json=response, headers=headers) as resp: resp.raise_for_status()`
        This `send` method is POSTing to `self.endpoint` (api.kodjima.com). This implies that `response` is something we are sending *to* the Kodjima/Gemma service.
        This is confusing. If `GemmaInterface` is a user-facing interface, why would its `send` method call *another* API (api.kodjima.com)?

        Re-interpreting the goal: "Подключить вызовы к Kodjima 3N E4B через её HTTP API".
        This might mean that `process_user_message` should be the one making these calls, and `GemmaInterface` is just a way to handle I/O for users who want to interact with our bot via a raw HTTP/JSON mechanism, *and this interaction itself is then processed and potentially sent to the actual Gemma LLM by `process_user_message`*.

        Let's assume `GemmaInterface` is for direct HTTP interaction with our bot:
        - `receive(self, payload: dict)`: The `payload` is the HTTP request body given to our application.
        - `send(self, response: dict)`: This is where it gets tricky. If this is an HTTP interaction, `send` should make the `response` available to the HTTP client that called our app. The provided `send` implementation (POSTing to `api.kodjima.com`) does not do this.

        Perhaps the task implies that when `INTERFACE=kodjima`, our bot *itself* acts as a client to the Kodjima API.
        - `receive(payload)`: Gets input (e.g. from CLI or a test script).
        - `process_user_message(payload)`: Generates a query for Kodjima.
        - `send(query_for_kodjima)`: Sends this query to `api.kodjima.com` using the structure given. The response from Kodjima would then need to be printed or returned.

        This interpretation makes `GemmaInterface.send` the method that *actually talks to the Gemma service*.
        But then, what does `GemmaInterface.receive` do? And how does the user get the final response from Gemma?

        Let's follow the provided `send` method structure literally for `GemmaInterface`.
        This means `GemmaInterface.send(response_dict)` will POST `response_dict` to `self.endpoint`.
        The `response_dict` must be what the Kodjima API expects.
        The `receive` method will just pass through the payload it gets.

        This implies that the `main.py` loop, when using `GemmaInterface`, will:
        1. `payload = await interface.receive(some_initial_data)` (e.g. from a CLI input that forms the `some_initial_data` dict)
        2. `response_for_gemma_api = await process_user_message(payload)` (this prepares the dict for Gemma API)
        3. `await interface.send(response_for_gemma_api)` (this posts to Gemma API. The result of this post is currently not handled by `send`)

        This still feels like `GemmaInterface.send` is not sending a response *to a user*, but *to the Gemma LLM*.
        If this is the case, `GemmaInterface` is not a user-facing I/O channel in the same way `TelegramInterface` is. It's more like a client for the Gemma LLM. This contradicts the idea of it being a pluggable interface *for user interaction*.

        Let's assume the user's intent was that `GemmaInterface` allows our application to *be called as if it's an API*, and the response from `process_user_message` should be returned to that caller. The `api_key` and `endpoint` in `GemmaInterface` would then be for *our application's endpoint*, not Kodjima's.
        However, the task is specific: `self.endpoint = "https://api.kodjima.com/v1/query"`.

        Okay, the most faithful interpretation of the provided `KodjimaInterface` (now `GemmaInterface`) snippet is:
        - `__init__`: Stores API key for `api.kodjima.com` and its endpoint.
        - `receive(payload)`: Takes a dict and returns it (presumably, this dict comes from the user in some way not defined by the interface itself, e.g. a CLI tool that calls `run(interface)`).
        - `send(response)`: Takes a dict and POSTs it to `api.kodjima.com`. It doesn't return anything to the original user. This is a "fire and forget" into the Kodjima API, or the response handling is missing.

        This structure is problematic for a generic `InterfaceBase` where `send` is meant to "Отправить ответ пользователю." If `send` posts to Kodjima, it's not sending an answer *to the user* who provided the initial `payload`.

        Let's assume there's a misunderstanding in the prompt's design of `KodjimaInterface.send`.
        A more logical `GemmaInterface` that fits the "pluggable interface" model:
        - `receive(payload)`: Receives a request (e.g. JSON from an HTTP POST to our app). This `payload` is the "user's message".
        - `send(response)`: Sends a response back to the original requester (e.g. as the HTTP response).
        The `api_key` and `endpoint` for `api.kodjima.com` would then belong in a *separate LLM client class* used by `process_user_message`.

        However, I must follow the task's literal specification for `KodjimaInterface` as closely as possible.
        So, `GemmaInterface.send` will indeed POST to `api.kodjima.com`.
        This means that `process_user_message` must generate a `response` dictionary that is suitable for the Kodjima API's `/v1/query` endpoint.
        The actual response *from* Kodjima is not captured or returned to the user by this `send` method. This is a major gap.

        Let's proceed with the literal interpretation. The `send` method will post to Kodjima.
        How the user gets a final answer is not defined by this interface.
        Perhaps the `send` method should be `async def query_llm(self, request_to_llm: dict) -> dict:` and return the LLM's response?
        But the base class is `async def send(self, response: dict) -> None:`.

        I'll implement it as specified, with the `send` method POSTing to the Kodjima API and not returning anything.
        The `receive` method will just pass through its input.
        """
        # For this interface, the 'payload' is the data that has been received
        # from an external source (e.g. a webhook POST to our app, or a CLI input).
        # This method prepares it for the 'process_user_message' function.
        # In the simplest case, it just returns the payload.
        logger.info(f"GemmaInterface received payload: {payload}")
        return payload # This payload will be passed to process_user_message

    async def send(self, gemma_api_request: dict) -> None:
        """
        Отправить запрос API Kodjima.
        'gemma_api_request' is the dictionary to be sent as JSON to the Gemma/Kodjima API.
        This method does not return the Gemma API's response to the caller.
        """
        async with aiohttp.ClientSession() as session:
            headers = {"Authorization": f"Bearer {self.api_key}"}
            logger.info(f"GemmaInterface sending request to {self.endpoint}: {gemma_api_request}")
            try:
                async with session.post(self.endpoint, json=gemma_api_request, headers=headers) as resp:
                    resp.raise_for_status() # Raise an exception for HTTP errors 4xx/5xx
                    # The response from Gemma API is not currently captured or returned.
                    # To make this useful, we would need to process resp.json()
                    # and the 'send' signature or mechanism would need to change.
                    logger.info(f"GemmaInterface request successful. Status: {resp.status}")
                    # response_data = await resp.json() # Example if we wanted the data
                    # logger.debug(f"Gemma API response: {response_data}")
            except aiohttp.ClientError as e:
                logger.error(f"GemmaInterface error sending request to {self.endpoint}: {e}", exc_info=True)
                # How to propagate this error? Current signature is -> None.
                # Re-raise for now, or handle as per application's error policy.
                raise
