# Технический План Проекта "Хронос"

## 1. Схема и Выбор Компонентов

Для реализации отказоустойчивой системы управления асинхронными задачами, мы спроектируем архитектуру, состоящую из четырех слабо связанных компонентов. Такой подход обеспечивает масштабируемость, надежность и простоту поддержки каждого элемента системы в отдельности.

### 1.1. Frontend-сервис (FastAPI)

*   **Роль:** Является "тонким" фасадом, точкой входа для всех взаимодействий с Telegram. Его ответственность строго ограничена задачами, которые могут быть выполнены мгновенно:
    1.  Прием и валидация входящих вебхуков.
    2.  Аутентификация и авторизация пользователя (если требуется).
    3.  Немедленное создание задачи в Базе Данных Состояний со статусом `pending`.
    4.  Мгновенная постановка задачи в Брокер Сообщений.
    5.  Отправка пользователю немедленного подтверждения с `task_id`.
*   **Принцип:** Сервис не должен выполнять никакую бизнес-логику, время выполнения которой может превышать несколько сотен миллисекунд, чтобы избежать таймаутов вебхука.

### 1.2. Брокер Сообщений (Message Broker)

*   **Выбор:** **RabbitMQ**.
*   **Обоснование:**
    *   **Надежность:** RabbitMQ предоставляет мощные гарантии доставки сообщений (acknowledgements, персистентность), что критически важно для задач, которые не должны быть потеряны.
    *   **Промышленный стандарт для задач:** В отличие от Redis, который является в первую очередь in-memory хранилищем, RabbitMQ был специально спроектирован для реализации сложных очередей задач. Он идеально подходит для парадигмы "отправил и забыл".
    *   **Функциональность:** Встроенная поддержка **Dead Letter Queues (DLQ)** и гибкие возможности маршрутизации (exchanges) позволяют реализовывать сложные сценарии обработки ошибок без дополнительных "костылей".
    *   **Альтернативы:** Kafka является избыточной для данной задачи, так как спроектирована для потоковой обработки событий (event streaming), а не для классических очередей. Redis прост, но требует более тщательной настройки для обеспечения сопоставимого уровня надежности.

### 1.3. Флот Воркеров (Worker Fleet)

*   **Выбор:** **Celery**.
*   **Обоснование:**
    *   **Зрелость и Сообщество:** Celery является де-факто стандартом для выполнения фоновых задач в экосистеме Python. Он обладает огромным сообществом, подробной документацией и проверен в бою в тысячах промышленных приложений.
    *   **Интеграция:** Имеет первоклассную "родную" поддержку RabbitMQ как брокера и PostgreSQL как бэкенда для хранения результатов.
    *   **Ключевые возможности:** Предоставляет "из коробки" важнейший для нас функционал:
        *   Автоматические повторные попытки (retries) с экспоненциальной задержкой.
        *   Простое горизонтальное масштабирование (запуском большего числа процессов-воркеров).
        *   Гибкая конфигурация и мониторинг (с помощью таких инструментов, как Flower).

### 1.4. База Данных Состояний (State Database)

*   **Выбор:** **PostgreSQL**.
*   **Обоснование:**
    *   **Надежность и Транзакционность:** Состояние задачи — критически важная информация. PostgreSQL обеспечивает полные **ACID-гарантии**, что исключает потерю данных или их противоречивое состояние (например, два воркера считают, что они оба выполняют одну и ту же задачу).
    *   **Структура и Гибкость:** Реляционная модель идеально подходит для хранения структурированных данных о задаче (ID, статус, временные метки). При этом, поддержка типа **JSONB** позволяет нам гибко хранить полезную нагрузку результата (`result_payload`) любой сложности, не жертвуя строгой схемой для основных полей.
    *   **Долговечность:** В отличие от in-memory решений (как Redis), PostgreSQL гарантирует, что состояние задач будет надежно сохранено на диске и переживет любые перезапуски системы.

## 2. Диаграмма Жизненного Цикла Запроса

Поскольку мы не можем встроить графическую диаграмму, жизненный цикл представлен в виде последовательности шагов, описывающих взаимодействие между компонентами системы.

1.  **Инициация:** `Пользователь` отправляет команду `/generate_report` в `Telegram`.
2.  **Вебхук:** `Telegram` немедленно вызывает эндпоинт нашего `FastAPI` сервиса.
3.  **Быстрая Обработка (FastAPI):**
    *   a. Валидирует запрос и авторизует пользователя.
    *   b. -> `PostgreSQL`: Создает новую запись в таблице `tasks` с уникальным `task_id` и статусом `pending`.
    *   c. -> `RabbitMQ`: Отправляет сообщение в очередь `task_queue`. Сообщение содержит `{ "task_id": "...", "user_id": "..." }`.
    *   d. <- `FastAPI`: Немедленно отвечает на вебхук Telegram статусом `200 OK`.
4.  **Обратная связь:** `FastAPI` (через экземпляр `aiogram.Bot`) -> `Telegram`: Отправляет пользователю мгновенное сообщение: `✅ "Задача принята в обработку. ID: <task_id>."`.
5.  **Захват Задачи (Celery):**
    *   a. Свободный `Celery Worker` получает сообщение о задаче из `RabbitMQ`. RabbitMQ гарантирует, что сообщение будет получено только одним воркером.
    *   b. -> `PostgreSQL`: Воркер атомарно обновляет статус задачи на `in_progress`.
6.  **Выполнение:** `Celery Worker` выполняет основную, длительную работу (например, генерацию отчета, анализ данных).
7.  **Завершение (Успех):**
    *   a. -> `PostgreSQL`: Воркер обновляет статус задачи на `completed` и сохраняет результат (например, ссылку на файл или JSON-данные) в поле `result_payload`.
    *   b. -> `Telegram`: Воркер инициирует отправку уведомления пользователю через `aiogram.Bot` о том, что задача успешно выполнена.
8.  **Завершение (Провал):**
    *   a. -> `PostgreSQL`: Воркер обновляет статус задачи на `failed` и записывает информацию об ошибке в `error_message`.
    *   b. -> `Telegram`: Воркер уведомляет пользователя о том, что при выполнении задачи произошла ошибка.

## 3. Контракты Данных (Data Contracts)

Для обеспечения строгой типизации и предсказуемости данных, которыми обмениваются компоненты системы, мы определяем следующие Pydantic-модели.

```python
# file: app/schemas.py

from pydantic import BaseModel, Field
from typing import Any, Dict
from enum import Enum
from datetime import datetime
import uuid

class TaskStatus(str, Enum):
    """Перечисление возможных статусов задачи."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"

class TaskQueueMessage(BaseModel):
    """
    Структура сообщения, отправляемого в очередь задач (RabbitMQ).
    Содержит минимально необходимую информацию для запуска воркера.
    """
    task_id: uuid.UUID
    user_id: int
    task_name: str  # Имя задачи, например, 'generate_annual_report'
    params: Dict[str, Any] = Field(default_factory=dict)

class TaskStateRecord(BaseModel):
    """
    Структура записи о состоянии задачи в базе данных (PostgreSQL).
    Представляет полную информацию о задаче на всем ее жизненном цикле.
    """
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    user_id: int
    task_name: str
    status: TaskStatus = TaskStatus.PENDING

    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    result_payload: Dict[str, Any] | None = None
    error_message: str | None = None

    class Config:
        orm_mode = True # Для совместимости с SQLAlchemy или другими ORM
```

## 4. Стратегия Обработки Ошибок и Устойчивости

Надежность является ключевым требованием проекта "Хронос". Система должна быть способна корректно обрабатывать сбои и восстанавливаться после них без потери данных.

### 4.1. Повторные попытки (Retries)

*   **Проблема:** Временные сбои (transient failures), такие как кратковременная недоступность сети, взаимоблокировка в базе данных (deadlock) или сбой внешнего API, не должны приводить к окончательному провалу задачи.
*   **Решение:** Каждая задача Celery будет по умолчанию настроена на автоматический повторный запуск в случае сбоя.
    *   **Механизм:** Мы будем использовать встроенный в Celery механизм `task.retry()`.
    *   **Стратегия задержки:** Будет применена стратегия **экспоненциальной задержки (exponential backoff)**. Например: `self.retry(exc=e, countdown=2**self.request.retries)`. Это означает, что задержка перед повторной попыткой будет увеличиваться (e.g., 2, 4, 8, 16 секунд), что позволяет снизить нагрузку на сбоящую систему.
    *   **Лимит:** Будет установлен максимальный лимит повторных попыток (например, 5 раз), чтобы избежать бесконечного выполнения "отравленных" задач.

### 4.2. "Мертвая очередь" (Dead Letter Queue - DLQ)

*   **Проблема:** Задачи, которые провалились даже после всех повторных попыток (например, из-за постоянной ошибки в коде или неверных входных данных), не должны оставаться в основной очереди и мешать обработке других задач.
*   **Решение:** Мы сконфигурируем RabbitMQ и Celery для использования механизма "мертвой очереди".
    *   **Механизм:** Когда задача исчерпывает все свои попытки, Celery не будет подтверждать ее выполнение (`ack`). RabbitMQ, видя это, автоматически переместит сообщение в специально настроенную очередь `dead_letter_queue`.
    *   **Мониторинг:** Эта очередь будет находиться под постоянным мониторингом. Наличие в ней сообщений является сигналом о серьезной проблеме, требующей вмешательства разработчика. Это позволяет проводить "посмертный" анализ сбойных задач, исправлять корень проблемы и, возможно, повторно запускать их вручную.

### 4.3. Идемпотентность

*   **Проблема:** В распределенной системе сообщение может быть доставлено более одного раза (at-least-once delivery). Если воркер выполнит одну и ту же задачу дважды, это может привести к нежелательным последствиям (например, дублирование данных, повторная отправка уведомления).
*   **Решение:** Логика каждого воркера будет спроектирована так, чтобы быть **идемпотентной** (повторное выполнение дает тот же результат, что и однократное).
    *   **Механизм:** Ключевым механизмом является **атомарное изменение статуса** в PostgreSQL. Прежде чем начать выполнение основной логики, воркер попытается "захватить" задачу:
        ```sql
        UPDATE tasks
        SET status = 'in_progress', updated_at = NOW()
        WHERE id = :task_id AND status = 'pending';
        ```
    *   **Логика проверки:** Если этот SQL-запрос вернет `ROW COUNT = 0` (т.е. не обновил ни одной строки), это будет означать, что другой воркер уже успел захватить эту задачу. В этом случае текущий воркер немедленно прекратит выполнение, считая задачу уже обработанной другим экземпляром. Это надежно предотвращает дублирование работы.
